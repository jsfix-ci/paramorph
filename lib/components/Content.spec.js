// Generated by CoffeeScript 1.12.7
(function() {
  var ContentLimiter, React, ReactDOMServer, elem, key, sinon,
    slice = [].slice;

  React = require("react");

  ReactDOMServer = require("react-dom/server");

  sinon = require("sinon");

  ContentLimiter = require("./Content")["default"];

  key = 0;

  elem = function() {
    var children, name;
    name = arguments[0], children = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return React.createElement(name, {
      key: key++
    }, children.length === 1 ? children[0] : children);
  };

  describe("Content", function() {
    var limitTests, noLimitTests, props, testedContent;
    props = null;
    testedContent = null;
    beforeEach(function() {
      return props = {
        limit: 1,
        respectLimit: true,
        test: true
      };
    });
    noLimitTests = [["limiting single sentence", elem("p", elem("b", "Ignorance"), " is a lack of ", elem("a", "knowledge"), ".")]];
    noLimitTests.forEach(function(params) {
      var children, testName;
      testName = params[0], children = params[1];
      return describe("when " + testName, function() {
        beforeEach(function() {
          return testedContent = React.createElement(ContentLimiter, props, children);
        });
        return it("contains not limited children", function() {
          var notLimited;
          notLimited = React.createElement("div", {
            className: "content"
          }, children);
          return ReactDOMServer.renderToStaticMarkup(testedContent).should.equal(ReactDOMServer.renderToStaticMarkup(notLimited));
        });
      });
    });
    limitTests = [["limiting two sentences", [elem("p", elem("b", "Ignorance"), " is a lack of ", elem("a", "knowledge"), ". "), "Knowledge is a lack of ignorance."], "<p><b>Ignorance</b> is a lack of <a>knowledge</a>.</p>"], ["limiting images", elem("div", elem("img"), elem("img"), elem("img")), "<div></div>"]];
    limitTests.forEach(function(params) {
      var children, expectedResult, testName;
      testName = params[0], children = params[1], expectedResult = params[2];
      return describe("when " + testName, function() {
        beforeEach(function() {
          return testedContent = React.createElement(ContentLimiter, props, children);
        });
        return it("contains limited children", function() {
          var limited;
          limited = "<div class=\"content\">" + expectedResult + "</div>";
          return ReactDOMServer.renderToStaticMarkup(testedContent).should.equal(limited);
        });
      });
    });
    return describe("with mapper configured", function() {
      var mapper;
      mapper = null;
      testedContent = null;
      beforeEach(function() {
        mapper = sinon.spy(function(node) {
          return elem("strong", "mapped");
        });
        return props = Object.assign({
          mapper: mapper
        }, props);
      });
      it("maps root component", function() {
        var children, markup;
        children = elem("p", "root");
        testedContent = React.createElement(ContentLimiter, props, children);
        markup = ReactDOMServer.renderToStaticMarkup(testedContent);
        return markup.should.equal("<div class=\"content\"><strong>mapped</strong></div>");
      });
      it("maps children with mapper before parents", function() {
        var children;
        children = elem("p", elem("b", "Ignorance"), " is a lack of ", elem("a", "knowledge"), ".");
        testedContent = React.createElement(ContentLimiter, props, children);
        ReactDOMServer.renderToStaticMarkup(testedContent);
        mapper.getCall(0).args[0].type.should.equal("b");
        mapper.getCall(1).args[0].type.should.equal("a");
        return mapper.getCall(2).args[0].type.should.equal("p");
      });
      return it("maps components after limiting", function() {
        var children;
        children = elem("p", ".", elem("b", "To be limited"), ".");
        testedContent = React.createElement(ContentLimiter, props, children);
        ReactDOMServer.renderToStaticMarkup(testedContent);
        return mapper.should.have.callCount(1);
      });
    });
  });

}).call(this);

//# sourceMappingURL=Content.spec.js.map
