// Generated by CoffeeScript 2.3.1
(function() {
  var FakePromise, Include, Layout, Loader, Page, sinon;

  sinon = require("sinon");

  ({FakePromise} = require("fake-promise"));

  ({Loader} = require("./Loader"));

  ({Layout, Include, Page} = require("../model"));

  describe("Loader", function() {
    var config, mocks, paramorph, tagPage, testedLoader;
    config = {
      title: "test",
      timezone: "UTC",
      collections: [],
      baseUrl: "http://paramorph.github.io/",
      image: "",
      locale: "en_US",
      menu: []
    };
    mocks = {
      projectStructure: {
        scan: sinon.stub()
      },
      frontMatter: {
        read: sinon.stub()
      },
      pageFactory: {
        create: sinon.stub()
      }
    };
    testedLoader = null;
    paramorph = null;
    beforeEach(function() {
      return testedLoader = new Loader(mocks.projectStructure, mocks.frontMatter, mocks.pageFactory);
    });
    afterEach(function() {
      mocks.projectStructure.scan.resetBehavior();
      mocks.projectStructure.scan.resetHistory();
      mocks.frontMatter.read.resetBehavior();
      mocks.frontMatter.read.resetHistory();
      mocks.pageFactory.create.resetBehavior();
      return mocks.pageFactory.create.resetHistory();
    });
    tagPage = {
      url: "/tag",
      tags: [],
      categories: [],
      output: false
    };
    describe("when loading empty project structure", function() {
      var struct;
      struct = {
        layouts: [],
        includes: [],
        collections: {}
      };
      beforeEach(function() {
        return mocks.projectStructure.scan.returns(FakePromise.resolve(struct));
      });
      return it(".load() throws Error with complain about missing tag page", function() {
        return testedLoader.load(config).then(function(result) {
          throw new Error(`expected rejection; got ${JSON.stringify(result)}`);
        }, function(error) {
          return error.message.should.eql("Couldn't find page of url '/tag' (used to render tag pages)");
        });
      });
    });
    describe("when loading a project structure containing only tag page", function() {
      var struct;
      struct = {
        layouts: [],
        includes: [],
        collections: {
          pages: [
            {
              name: "tag",
              path: "./_pages/tag.markdown"
            }
          ]
        }
      };
      beforeEach(async function() {
        mocks.projectStructure.scan.returns(FakePromise.resolve(struct));
        mocks.frontMatter.read.returns(FakePromise.resolve({}));
        mocks.pageFactory.create.returns(tagPage);
        return paramorph = (await testedLoader.load(config));
      });
      return it(".load() returns empty Paramorph instance", function() {
        paramorph.layouts.should.eql({});
        paramorph.includes.should.eql({});
        paramorph.pages.should.eql({
          "/tag": tagPage
        });
        paramorph.categories.should.eql({});
        paramorph.tags.should.eql({});
        return paramorph.config.should.eql(config);
      });
    });
    describe("when loading a project structure containing only a page with missing category", function() {
      var paramorphPromise, struct;
      struct = {
        layouts: [],
        includes: [],
        collections: {
          pages: [
            {
              name: "tag",
              path: "./_pages/tag.markdown"
            }
          ]
        }
      };
      paramorphPromise = null;
      beforeEach(function() {
        mocks.projectStructure.scan.returns(FakePromise.resolve(struct));
        mocks.frontMatter.read.returns(FakePromise.resolve({}));
        return mocks.pageFactory.create.returns(Object.assign({}, tagPage, {
          categories: ["missing"]
        }));
      });
      return it(".load() throws Error", function() {
        return testedLoader.load(config).then(function(result) {
          throw new Error(`expected rejection; got result=${JSON.stringify(result)}`);
        }, function(error) {
          return error.message.should.equal("Couldn't find category page(s): [{\"page\":\"/tag\",\"category\":\"missing\"}]");
        });
      });
    });
    describe("when loading a project structure containing layouts", function() {
      var struct;
      struct = {
        layouts: [
          {
            name: "default",
            path: "./_layouts/default.ts"
          }
        ],
        includes: [],
        collections: {
          pages: [
            {
              name: "tag",
              path: "./_pages/tag.markdown"
            }
          ]
        }
      };
      beforeEach(async function() {
        mocks.projectStructure.scan.returns(FakePromise.resolve(struct));
        mocks.frontMatter.read.returns(FakePromise.resolve({}));
        mocks.pageFactory.create.returns(tagPage);
        return paramorph = (await testedLoader.load(config));
      });
      return it(".load() returns Paramorph containing layouts", function() {
        Object.keys(paramorph.layouts).should.have.length(1);
        return paramorph.layouts.default.should.eql(new Layout("default", "./_layouts/default.ts"));
      });
    });
    describe("when loading a project structure containing includes", function() {
      var struct;
      struct = {
        layouts: [],
        includes: [
          {
            name: "Feed",
            path: "./_includes/Feed.ts"
          }
        ],
        collections: {
          pages: [
            {
              name: "tag",
              path: "./_pages/tag.markdown"
            }
          ]
        }
      };
      beforeEach(async function() {
        mocks.projectStructure.scan.returns(FakePromise.resolve(struct));
        mocks.frontMatter.read.returns(FakePromise.resolve({}));
        mocks.pageFactory.create.returns(tagPage);
        return paramorph = (await testedLoader.load(config));
      });
      return it(".load() returns Paramorph containing includes", function() {
        Object.keys(paramorph.includes).should.have.length(1);
        return paramorph.includes.Feed.should.eql(new Include("Feed", "./_includes/Feed.ts"));
      });
    });
    return describe("when loading a project structure containing page", function() {
      var matterPromise, paramorphPromise, postSource, struct;
      postSource = {
        name: "hello-world",
        path: "./_post/hello-world.md"
      };
      struct = {
        layouts: [],
        includes: [],
        collections: {
          posts: [postSource]
        }
      };
      matterPromise = null;
      paramorphPromise = null;
      beforeEach(function(end) {
        mocks.projectStructure.scan.returns(FakePromise.resolve(struct));
        matterPromise = new FakePromise;
        mocks.frontMatter.read.returns(matterPromise);
        paramorphPromise = testedLoader.load(config);
        return setImmediate(end);
      });
      it("calls frontMatter.read(...)", function() {
        return mocks.frontMatter.read.should.have.callCount(1).and.have.been.calledWith(postSource);
      });
      return describe("and after resolving frontMatter promise", function() {
        var matter, page;
        matter = {
          title: "Hello, World!",
          description: "Just a first post."
        };
        page = new Page("/hello-world", "Hello, World!", "Just a first post.", null, "posts", "default", "./_post/hello-world.md", true, true, [], [], 0);
        beforeEach(function(end) {
          mocks.pageFactory.create.returns(page);
          matterPromise.resolve(matter);
          return setImmediate(end);
        });
        return it('calls pageFactory.create(...)', function() {
          return mocks.pageFactory.create.should.have.callCount(1).and.have.been.calledWith(postSource, "posts", matter);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=Loader.spec.js.map
